---
id:
  "{ date:YYYYMMDDHHmm }":
type: permanent
tags:
---
# 命题：起一个线程的本质是执行一个函数
## 定义 / 结论
- <精炼阐述>
执行 std::thread(func1) 时， 本质上就是将这个fun1放到别的线程中执行，通过mutex，wait等方式，控制线程的行进逻辑。

## 机制 / 因果
- <为什么对>
以下代码模拟两种情况， 分别是执行一次和多次， 他们通过某个condition来判断是否需要执行工作。
## 操作 / 代码要点
1) <步骤>
2) <关键API/陷阱>

``` cpp

// 模式A：一次性线程
void one_time_task() {
    // 做一些初始化
    cv.wait(lock, condition);  // 等待开始信号
    // 做具体工作
    // 函数结束 → 线程结束
}

// 模式B：工作线程（常用）
void worker_thread() {
    while (keep_running) {     // 外层循环控制线程生命周期
        cv.wait(lock, has_work);  // 等待工作
        do_work();             // 处理工作
        // 回到while开头继续等待下一个任务
    }
    // keep_running=false时，循环结束，函数结束，线程结束
}
```


## 反例 / 边界
- <何时不成立>


## 连接
- 定义 →【内容摘录】 永久卡A-四类卡片分工
- 因果 →【】这个概念从哪里来，到哪里去
- 实现 → 【具体的代码实现SOP 流程模板】SOP-永久卡模板（Templater版）
- 应用 →【Project中是否用到】 MOC-并发-导航
- 证据 → 【内容摘录、文献证明】[[C++多线程并发基础入门教程]]
