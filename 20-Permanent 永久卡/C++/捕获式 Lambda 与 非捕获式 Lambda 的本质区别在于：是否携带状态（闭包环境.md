---
id:
  "{ date:YYYYMMDDHHmm }":
type: permanent
tags:
---
# 命题：捕获式 Lambda 与 非捕获式 Lambda 的本质区别在于：是否携带状态（闭包环境
非捕获式lambda，编译后产生的是一个函数，可以用一个函数指针传递，轻量级，但是中间也生成一个闭包，只是可以支持隐式转换为函数指针。

捕获式Lambda，编译后产生的是一个闭包，也就是一个匿名类， 需要分配内存地址，且无法传递给一个指针，这个分配可能在堆或者栈上，可以作为对象拷贝。
他携带了一个**状态**
- **非捕获式 lambda**（`[](...) { ... }`，不捕任何变量）  
    编译器生成一个**闭包类型**（有 `operator()` 的结构体），**其状态为空（大小通常为 1 字节，满足不同于 0 的对象规则）**；同时**生成一个静态函数**用于**隐式转换为函数指针**。  
    👉 因而它**可以赋值给函数指针**：`int(*)(int,int)`；轻量、可当 C 回调用。
    **<font color="#ff0000">这个地方，应该也是一个闭包类型对象，只是有一条标准转换通往函数指针</font>**
- **捕获式 lambda**（`[x]`, `[&x]`, `[=]`, `[&]`, `[this]` 等）  
    编译器生成一个**携带成员字段的闭包对象**（把捕获的变量/指针存成成员）；**不能隐式转换为函数指针**（因为需要那份状态）。  
    👉 但它**可以**：
    
    - 作为对象传递/拷贝（通常**不涉及堆分配**，就和普通小 struct 一样在栈/寄存器上传递；只有放进 `std::function` 且超出 SBO 时才可能堆分配）。
        
    - 包成 `std::function`、或用“__trampoline + void_ userData_*”桥接到 C 回调。
        

> 纠正你原话里的两点：
> 
> 1. “非捕获式编译后产生的是一个函数”——更准确说：**产生一个无状态闭包类型**，并且**可转为函数指针**（编译器会合成一个静态函数供转换）。
>     
> 2. “捕获式需要分配内存地址/堆”——**不一定会堆分配**。它就是个普通对象，放哪由你决定（栈/成员/静态/放入容器）。只有装进 `std::function` 且超过小对象优化才可能堆分配。
>
## 机制 / 因果
- <为什么对>

## 操作 / 代码要点
1) <步骤>
2) <关键API/陷阱>

## 反例 / 边界
- <何时不成立>

## 引申/ 同类型
- <同类型的有什么>
## 连接
- 定义 →【内容摘录】 永久卡A-四类卡片分工
- 因果 →【】这个概念从哪里来，到哪里去
- 实现 → 【具体的代码实现SOP 流程模板】SOP-永久卡模板（Templater版）
- 应用 →【Project中是否用到】 MOC-并发-导航
- 证据 → 【内容摘录、文献证明】[[C++Lambda表达式]]  [[C++函数指针相关的内容]]
