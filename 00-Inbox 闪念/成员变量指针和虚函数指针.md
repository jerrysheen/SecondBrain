# 2025-09-30 11:47 å¿«é€Ÿæƒ³æ³•
- æƒ³æ³•ï¼š<ä¸€å¥è¯é—®é¢˜/çµæ„Ÿ>
- èƒŒæ™¯/è§¦å‘ï¼šhttps://chatgpt.com/c/68da39cf-3e64-832f-b060-27856e9d87b7
- ä¸‹ä¸€æ­¥ï¼š- [ ] è½¬Literature / - [ ] ç›´æ¥Permanentï¼Ÿ
tags: [fleeting]


ä½ å·²ç»æŠ“åˆ°å…³é”®äº†ï¼Œä½†æœ‰ä¸¤ç‚¹è¦çº æ­£ï¼š

1. **éé™æ€æˆå‘˜å‡½æ•°æŒ‡é’ˆï¼ˆpointer-to-member function, PMFï¼‰ä¸æ˜¯â€œå¯¹è±¡æ— å…³â€çš„**ã€‚
    
2. `*pmf` ä¸æ˜¯å›ºå®šå†™æ³•ï¼›å›ºå®šçš„æ˜¯**è°ƒç”¨è¯­æ³•**ï¼š`(obj.*pmf)(args...)` æˆ– `(ptr->*pmf)(args...)`ã€‚
    

ä¸‹é¢æŠŠæ¦‚å¿µã€è¯­æ³•ã€æ˜“é”™ç‚¹è®²æ¸…ã€‚

---

## 1. å®ƒåˆ°åº•æ˜¯ä»€ä¹ˆï¼Ÿ

`struct A {     int mul(int x) { return k * x; }     int k = 2; };  int (A::*pmf)(int) = &A::mul;  // pmf çš„ç±»å‹ï¼šint (A::*)(int) A a; int r = (a.*pmf)(3);           // é€šè¿‡â€œå¯¹è±¡ aâ€è°ƒç”¨`

- `&A::mul` çš„ç±»å‹ä¸æ˜¯æ™®é€šå‡½æ•°æŒ‡é’ˆï¼Œè€Œæ˜¯**æŒ‡å‘ A çš„æˆå‘˜å‡½æ•°çš„æŒ‡é’ˆ**ï¼š`int (A::*)(int)`ã€‚
    
- **å¿…é¡»**é…åˆä¸€ä¸ªå¯¹è±¡ï¼ˆæˆ–æŒ‡å‘å¯¹è±¡çš„æŒ‡é’ˆï¼‰æ‰èƒ½è°ƒç”¨ï¼š
    
    - å¯¹è±¡ï¼š`(a.*pmf)(3)`
        
    - æŒ‡é’ˆï¼š`(pa->*pmf)(3)`
        
- ä¸ºä»€ä¹ˆå¿…é¡»è¦å¯¹è±¡ï¼Ÿå› ä¸ºéé™æ€æˆå‘˜å‡½æ•°æœ‰ä¸€ä¸ª**éšå¼çš„ `this` å‚æ•°**ï¼Œå®ƒè¦çŸ¥é“â€œå¯¹å“ªä¸€ä¸ªå®ä¾‹â€çš„ `k` åšä¹˜æ³•ã€‚
    

> å¯¹æ¯”ï¼š**é™æ€æˆå‘˜å‡½æ•°**æ²¡æœ‰ `this`ï¼Œç±»å‹å°±æ˜¯æ™®é€šå‡½æ•°æŒ‡é’ˆï¼ˆ`Ret(*)(Args...)`ï¼‰ï¼Œå¯ä»¥åƒæ™®é€šå‡½æ•°é‚£æ ·ç”¨ï¼Œæ— éœ€å¯¹è±¡ã€‚

---

## 2. å£°æ˜ä¸è°ƒç”¨è¯­æ³•

### å£°æ˜

`// ç›´æ¥å†™ int (A::*pmf)(int) = &A::mul;  // ç”¨åˆ«åæ›´æ¸…æ™° using PMF = int (A::*)(int); PMF pmf2 = &A::mul;  // è‡ªåŠ¨æ¨å¯¼ auto pmf3 = &A::mul; // ç±»å‹è‡ªåŠ¨æ¨ä¸º int (A::*)(int)`

### è°ƒç”¨ï¼ˆè¯­æ³•å›ºå®šï¼‰

`A a; A* p = &a;  (a.*pmf)(3);    // å¯¹è±¡ + .*  (p->*pmf)(3);   // æŒ‡é’ˆ + ->*`

> æ³¨æ„ï¼š**å¿…é¡»æœ‰æ‹¬å·**æŠŠ `a.*pmf` æˆ– `p->*pmf` å›¢èµ·æ¥ï¼Œå†è·Ÿ `(å‚æ•°)`ã€‚

---

## 3. `std::invoke`ï¼šæ›´ç»Ÿä¸€æ›´å°‘æ‹¬å·

`#include <functional>  A a; std::invoke(&A::mul, a, 3);   // ç­‰ä»·äº (a.*pmf)(3) std::invoke(&A::mul, &a, 3);  // ä¹Ÿå¯ä»¥ä¼ æŒ‡é’ˆ`

`std::invoke` èƒ½ç»Ÿä¸€è°ƒç”¨æ™®é€šå‡½æ•°ã€æˆå‘˜å‡½æ•°æŒ‡é’ˆã€å‡½æ•°å¯¹è±¡/Î» ç­‰ï¼Œå†™æ³•æ›´å¹²å‡€ã€‚

---

## 4. `const` / `volatile` / `noexcept` çš„å½±å“

æˆå‘˜å‡½æ•°ç±»å‹è¦å¸¦ä¸Šé™å®šç¬¦ï¼š

`struct B {     int f(int) const noexcept { return 0; } };  int (B::*p1)(int) const noexcept = &B::f; // ç±»å‹å¿…é¡»åŒ¹é…`

**ç­¾åä¸åŒ¹é…**ä¼šç¼–è¯‘é”™è¯¯ï¼ˆå°±åƒæ™®é€šå‡½æ•°æŒ‡é’ˆé‚£æ ·ä¸¥æ ¼ï¼‰ã€‚

---

## 5. è™šå‡½æ•° & ç»§æ‰¿

`struct Base { virtual int g(int){ return 1; } }; struct Der : Base { int g(int) override { return 2; } };  int (Base::*pg)(int) = &Base::g; Der d; int x = (d.*pg)(5); // é€šè¿‡è™šæ´¾å‘ï¼Œè°ƒç”¨åˆ° Der::gï¼Œè¿”å› 2`

- æˆå‘˜å‡½æ•°æŒ‡é’ˆ**å°Šé‡è™šå‡½æ•°æœºåˆ¶**ï¼šç»ç”±åŸºç±»ç±»å‹çš„ PMF è°ƒåˆ°æ´¾ç”Ÿç±»å®ç°ã€‚
    
- å¤šé‡ç»§æ‰¿/è™šç»§æ‰¿ä¸‹ï¼ŒPMF çš„å†…éƒ¨è¡¨ç¤ºå¯èƒ½åŒ…å«**è°ƒæ•´ä¿¡æ¯**ï¼ˆä¸ä»…ä»…æ˜¯â€œä»£ç åœ°å€â€ï¼‰ï¼Œå› æ­¤**ç»å¯¹ä¸è¦æŠŠæˆå‘˜å‡½æ•°æŒ‡é’ˆå¼ºè½¬ä¸ºæ™®é€šå‡½æ•°æŒ‡é’ˆ**ã€‚
    

---

## 6. æŒ‡å‘â€œæ•°æ®æˆå‘˜â€çš„æŒ‡é’ˆï¼ˆé¡ºå¸¦çŸ¥é“ä¸€ä¸‹ï¼‰

`int A::* pmd = &A::k;  // æŒ‡å‘æ•°æ®æˆå‘˜ k A a; int v = a.*pmd;        // é€šè¿‡å¯¹è±¡å–å€¼ int u = (&a->*pmd);    // é€šè¿‡æŒ‡é’ˆå–å€¼`

è¯­æ³•ä¸ PMF ç±»ä¼¼ï¼Œä¹Ÿæ˜¯ `.*` / `->*`ã€‚

---

## 7. å¸¸è§æ˜“é”™ç‚¹

- âŒ **â€œå¯¹è±¡æ— å…³åœ°è°ƒç”¨éé™æ€æˆå‘˜å‡½æ•°â€**ï¼šä¸å¯èƒ½ã€‚å¿…é¡»æœ‰å¯¹è±¡ï¼ˆ`this`ï¼‰ã€‚å¦‚æœæƒ³â€œå¯¹è±¡æ— å…³â€ï¼ŒæŠŠæˆå‘˜å‡½æ•°æ”¹æˆ `static` æˆ–ç”¨è‡ªç”±å‡½æ•°/å¯è°ƒç”¨å¯¹è±¡ã€‚
    
- âŒ **æŠŠæˆå‘˜å‡½æ•°æŒ‡é’ˆå½“æ™®é€šå‡½æ•°æŒ‡é’ˆç”¨**ï¼šç±»å‹ä¸åŒï¼ŒABI è¡¨ç¤ºä¹Ÿå¯èƒ½ä¸åŒï¼Œä¸èƒ½äº’è½¬ã€‚
    
- âŒ **å°‘äº†æ‹¬å·**ï¼š`a.*pmf(3)` ä¼šè¢«å½“ä½œ `a.*(pmf(3))` è§£æï¼Œå¿…é¡»å†™ `(a.*pmf)(3)`ã€‚
    
- âŒ **é‡è½½æ­§ä¹‰**ï¼šè‹¥æœ‰é‡è½½ï¼Œå–åœ°å€éœ€æŒ‡æ˜ç­¾åï¼š
    
    `struct C { int h(int); double h(double) const; }; int  (C::*pInt)(int)        = static_cast<int  (C::*)(int)>(&C::h); double (C::*pD)(double)const= static_cast<double(C::*)(double)const>(&C::h);`
    

---

## 8. å’Œ `std::function`/Î» çš„é…åˆ

å¦‚æœä½ æƒ³â€œæŠŠå¯¹è±¡å’Œæˆå‘˜å‡½æ•°æ‰“åŒ…æˆä¸€ä¸ªå¯ç›´æ¥è°ƒç”¨çš„å›è°ƒâ€ï¼Œæœ‰ä¸‰ç§å¸¸è§å†™æ³•ï¼š

`A a;  // 1) Î» æ•è·å¯¹è±¡ auto cb1 = [&a](int x){ return a.mul(x); };  // 2) bind auto cb2 = std::bind(&A::mul, &a, std::placeholders::_1); // ä¸æ¨èï¼ŒÎ» æ›´æ¸…æ™°  // 3) std::mem_fn + ç»‘å®šå¯¹è±¡ auto cb3 = std::bind(std::mem_fn(&A::mul), &a, std::placeholders::_1);  // éƒ½å¯ä»¥å­˜è¿› std::function<int(int)> std::function<int(int)> f = cb1;`

---

## 9. å°ç»“ï¼ˆæŠŠè¯¯åŒºæ°æ­£ï¼‰

- **PMF ä¸æ˜¯é™æ€è°ƒç”¨**ï¼Œæ›´ä¸æ˜¯â€œå¯¹è±¡æ— å…³â€ã€‚å®ƒåªæ˜¯â€œæŠŠè¦è°ƒçš„é‚£ä¸ªæˆå‘˜å‡½æ•°**é€‰å‡ºæ¥**â€ï¼ŒçœŸæ­£è°ƒç”¨æ—¶**ä»éœ€è¦å¯¹è±¡/æŒ‡é’ˆ**æ¥æä¾› `this`ã€‚
    
- **è°ƒç”¨è¯­æ³•å›ºå®š**ï¼š`(obj.*pmf)(...)` / `(ptr->*pmf)(...)`ï¼Œæˆ–è€…ç”¨ `std::invoke(&A::mul, obj, ...)`ã€‚
    
- **ç­¾åå¿…é¡»ç²¾ç¡®åŒ¹é…**ï¼ˆå« `const`/`noexcept`/é‡è½½ï¼‰ã€‚
    
- **è™šå‡½æ•°ç…§æ ·è™šæ´¾å‘**ï¼›å¤šé‡ç»§æ‰¿ä¸‹ä¸è¦æŠŠå®ƒå½“ä½œæ™®é€šå‡½æ•°æŒ‡é’ˆçœ‹å¾…ã€‚
    

å¦‚æœä½ æ„¿æ„ï¼Œæˆ‘å¯ä»¥ç»™ä½ ä¸€ä¸ª**â€œæˆå‘˜å‡½æ•°æŒ‡é’ˆé€ŸæŸ¥è¡¨â€**ï¼ˆå«å„ç§é™å®šç¬¦ã€é‡è½½ã€ç»§æ‰¿ã€`std::invoke` ç­‰å¯¹ç…§ä¾‹ï¼‰ï¼Œæ–¹ä¾¿ä½ åœ¨é¡¹ç›®é‡Œéšæ—¶ç¿»ã€‚



å¯¹çš„ï¼`pmf` åªæ˜¯ä½ è‡ªå·±ç»™å˜é‡èµ·çš„åå­—è€Œå·²ï¼Œ**ä¸æ˜¯**å†…ç½®å…³é”®å­—æˆ–ä¿ç•™åã€‚å¤§å®¶å¸¸ç”¨ `pmf` åªæ˜¯å› ä¸ºå®ƒåƒ _pointer-to-member function_ çš„ç¼©å†™ï¼Œè¯»èµ·æ¥é¡ºå£ã€‚

å¿«é€Ÿå¯¹ç…§ğŸ‘‡

```cpp
struct A { int mul(int x){ return x; } };

// è¿™ä¸‰ç§éƒ½ä¸€æ ·ï¼šåªæ˜¯å˜é‡åä¸åŒ
int (A::*pmf)(int)      = &A::mul;  // å¸¸è§å†™æ³•ï¼ˆpmf=å˜é‡åï¼‰
int (A::*memberFn)(int) = &A::mul;  // æ›´è¯­ä¹‰åŒ–çš„å˜é‡å
auto ptrToMul           = &A::mul;  // ç”¨ auto è®©ç¼–è¯‘å™¨æ¨å¯¼ç±»å‹
```

ä¹Ÿå¯ä»¥å…ˆèµ·**ç±»å‹åˆ«å**å†å£°æ˜å˜é‡ï¼š

```cpp
using PMF = int (A::*)(int);  // PMF æ˜¯ç±»å‹åˆ«åï¼Œä¸æ˜¯å˜é‡
PMF f = &A::mul;              // f æ‰æ˜¯å˜é‡
```

è°ƒç”¨æ–¹å¼å›ºå®šï¼Œç”¨ `.*` / `->*`ï¼ˆæˆ– `std::invoke`ï¼‰ï¼š

```cpp
A a;
int r1 = (a.*pmf)(3);
int r2 = ( &a->*memberFn )(5);
int r3 = std::invoke(&A::mul, a, 7);  // æ›´é€šç”¨çš„è°ƒç”¨æ³•
```

é¡ºå¸¦ï¼š**æ•°æ®æˆå‘˜æŒ‡é’ˆ**ä¹Ÿæ˜¯åŒç†ï¼Œå˜é‡åéšä¾¿èµ·ï¼š

```cpp
int A::* pmd = &A::value;  // pmd åªæ˜¯å˜é‡å
```

ç»“è®ºï¼š`pmf` åªæ˜¯ä¸ªæ™®é€šå˜é‡åï¼›çœŸæ­£â€œç‰¹æ®Šâ€çš„åªæ˜¯**ç±»å‹**ï¼ˆ`int (A::*)(int)`ï¼‰å’Œ**è°ƒç”¨è¯­æ³•**ã€‚