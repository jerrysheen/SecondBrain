# 2025-09-30 11:47 快速想法
- 想法：<一句话问题/灵感>
- 背景/触发：https://chatgpt.com/c/68da39cf-3e64-832f-b060-27856e9d87b7
- 下一步：- [ ] 转Literature / - [ ] 直接Permanent？
tags: [fleeting]


你已经抓到关键了，但有两点要纠正：

1. **非静态成员函数指针（pointer-to-member function, PMF）不是“对象无关”的**。
    
2. `*pmf` 不是固定写法；固定的是**调用语法**：`(obj.*pmf)(args...)` 或 `(ptr->*pmf)(args...)`。
    

下面把概念、语法、易错点讲清。

---

## 1. 它到底是什么？

`struct A {     int mul(int x) { return k * x; }     int k = 2; };  int (A::*pmf)(int) = &A::mul;  // pmf 的类型：int (A::*)(int) A a; int r = (a.*pmf)(3);           // 通过“对象 a”调用`

- `&A::mul` 的类型不是普通函数指针，而是**指向 A 的成员函数的指针**：`int (A::*)(int)`。
    
- **必须**配合一个对象（或指向对象的指针）才能调用：
    
    - 对象：`(a.*pmf)(3)`
        
    - 指针：`(pa->*pmf)(3)`
        
- 为什么必须要对象？因为非静态成员函数有一个**隐式的 `this` 参数**，它要知道“对哪一个实例”的 `k` 做乘法。
    

> 对比：**静态成员函数**没有 `this`，类型就是普通函数指针（`Ret(*)(Args...)`），可以像普通函数那样用，无需对象。

---

## 2. 声明与调用语法

### 声明

`// 直接写 int (A::*pmf)(int) = &A::mul;  // 用别名更清晰 using PMF = int (A::*)(int); PMF pmf2 = &A::mul;  // 自动推导 auto pmf3 = &A::mul; // 类型自动推为 int (A::*)(int)`

### 调用（语法固定）

`A a; A* p = &a;  (a.*pmf)(3);    // 对象 + .*  (p->*pmf)(3);   // 指针 + ->*`

> 注意：**必须有括号**把 `a.*pmf` 或 `p->*pmf` 团起来，再跟 `(参数)`。

---

## 3. `std::invoke`：更统一更少括号

`#include <functional>  A a; std::invoke(&A::mul, a, 3);   // 等价于 (a.*pmf)(3) std::invoke(&A::mul, &a, 3);  // 也可以传指针`

`std::invoke` 能统一调用普通函数、成员函数指针、函数对象/λ 等，写法更干净。

---

## 4. `const` / `volatile` / `noexcept` 的影响

成员函数类型要带上限定符：

`struct B {     int f(int) const noexcept { return 0; } };  int (B::*p1)(int) const noexcept = &B::f; // 类型必须匹配`

**签名不匹配**会编译错误（就像普通函数指针那样严格）。

---

## 5. 虚函数 & 继承

`struct Base { virtual int g(int){ return 1; } }; struct Der : Base { int g(int) override { return 2; } };  int (Base::*pg)(int) = &Base::g; Der d; int x = (d.*pg)(5); // 通过虚派发，调用到 Der::g，返回 2`

- 成员函数指针**尊重虚函数机制**：经由基类类型的 PMF 调到派生类实现。
    
- 多重继承/虚继承下，PMF 的内部表示可能包含**调整信息**（不仅仅是“代码地址”），因此**绝对不要把成员函数指针强转为普通函数指针**。
    

---

## 6. 指向“数据成员”的指针（顺带知道一下）

`int A::* pmd = &A::k;  // 指向数据成员 k A a; int v = a.*pmd;        // 通过对象取值 int u = (&a->*pmd);    // 通过指针取值`

语法与 PMF 类似，也是 `.*` / `->*`。

---

## 7. 常见易错点

- ❌ **“对象无关地调用非静态成员函数”**：不可能。必须有对象（`this`）。如果想“对象无关”，把成员函数改成 `static` 或用自由函数/可调用对象。
    
- ❌ **把成员函数指针当普通函数指针用**：类型不同，ABI 表示也可能不同，不能互转。
    
- ❌ **少了括号**：`a.*pmf(3)` 会被当作 `a.*(pmf(3))` 解析，必须写 `(a.*pmf)(3)`。
    
- ❌ **重载歧义**：若有重载，取地址需指明签名：
    
    `struct C { int h(int); double h(double) const; }; int  (C::*pInt)(int)        = static_cast<int  (C::*)(int)>(&C::h); double (C::*pD)(double)const= static_cast<double(C::*)(double)const>(&C::h);`
    

---

## 8. 和 `std::function`/λ 的配合

如果你想“把对象和成员函数打包成一个可直接调用的回调”，有三种常见写法：

`A a;  // 1) λ 捕获对象 auto cb1 = [&a](int x){ return a.mul(x); };  // 2) bind auto cb2 = std::bind(&A::mul, &a, std::placeholders::_1); // 不推荐，λ 更清晰  // 3) std::mem_fn + 绑定对象 auto cb3 = std::bind(std::mem_fn(&A::mul), &a, std::placeholders::_1);  // 都可以存进 std::function<int(int)> std::function<int(int)> f = cb1;`

---

## 9. 小结（把误区掰正）

- **PMF 不是静态调用**，更不是“对象无关”。它只是“把要调的那个成员函数**选出来**”，真正调用时**仍需要对象/指针**来提供 `this`。
    
- **调用语法固定**：`(obj.*pmf)(...)` / `(ptr->*pmf)(...)`，或者用 `std::invoke(&A::mul, obj, ...)`。
    
- **签名必须精确匹配**（含 `const`/`noexcept`/重载）。
    
- **虚函数照样虚派发**；多重继承下不要把它当作普通函数指针看待。
    

如果你愿意，我可以给你一个**“成员函数指针速查表”**（含各种限定符、重载、继承、`std::invoke` 等对照例），方便你在项目里随时翻。



对的！`pmf` 只是你自己给变量起的名字而已，**不是**内置关键字或保留名。大家常用 `pmf` 只是因为它像 _pointer-to-member function_ 的缩写，读起来顺口。

快速对照👇

```cpp
struct A { int mul(int x){ return x; } };

// 这三种都一样：只是变量名不同
int (A::*pmf)(int)      = &A::mul;  // 常见写法（pmf=变量名）
int (A::*memberFn)(int) = &A::mul;  // 更语义化的变量名
auto ptrToMul           = &A::mul;  // 用 auto 让编译器推导类型
```

也可以先起**类型别名**再声明变量：

```cpp
using PMF = int (A::*)(int);  // PMF 是类型别名，不是变量
PMF f = &A::mul;              // f 才是变量
```

调用方式固定，用 `.*` / `->*`（或 `std::invoke`）：

```cpp
A a;
int r1 = (a.*pmf)(3);
int r2 = ( &a->*memberFn )(5);
int r3 = std::invoke(&A::mul, a, 7);  // 更通用的调用法
```

顺带：**数据成员指针**也是同理，变量名随便起：

```cpp
int A::* pmd = &A::value;  // pmd 只是变量名
```

结论：`pmf` 只是个普通变量名；真正“特殊”的只是**类型**（`int (A::*)(int)`）和**调用语法**。