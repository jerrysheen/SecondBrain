---
source: https://chatgpt.com/c/68d75a7a-97d0-8328-a4b7-c03e1c46d02b
author: ""
year: ""
type: paper|blog|doc|code
---
# 摘录要点
快速判断放哪儿（决策树）
只是在列“**怎么写/函数原型/示例**”？→ 摘录/Reference
能总结成“**必须/禁止/若…则…”的规则**？→ 永久卡
一套固定“步骤”可复用？→ SOP/Project
需要导航不同规则与项目？→ MOC
> [!note]
> 
> 永久卡 1：std::thread 没有“关闭”，只有 join 或 detach
> 
> **结论：** std::thread 仅提供 join（回收）与 detach（后台运行）两种归宿；析构且仍 joinable 会 std::terminate()。
> 
> **要点：**
> 	t.joinable() 为真时禁止析构；
> 	detach 后线程不可管理，资源由运行时清理；
> 	RAII 管理（见下一卡）。
> **反例/边界：**
> 	误以为“close()”导致资源泄漏或崩溃。
> **最小代码：**
> 
```
	std::thread t(worker);
	// 必须二选一：
	t.join();         // or
	// t.detach();
```

连接：应用→ RAII Joiner 模式确保异常安全回收；反例→ 析构触发 terminate 的常见路径
# 我的解释（不要省）
比如， 怎么样写语法， std::thread表示开启一个新的线程之类的， 应该写到摘录中。
而 std::thread没有关闭，只有join、detach，可以作为一个永久卡， 因为这是一个**结论**，可以理解为，一个结论，一个考点，都可以作为永久卡。
然后这个结论的核心，就是延申出来的下一个考点之类的内容，以及写一些简单的代码案例， 做一些解释之类的。

永久卡 2：RAII Joiner 模式确保异常安全线程回收
永久卡 3：`std::jthread` 析构会请求停止并 join（C++20）
永久卡 4：线程对象是**可移动不可拷贝**，所有权显式转移

- **原始 API/长代码**：放 **摘录/Reference**（`[Lit] C++ 并发基本操作`），方便查。
- **从语法抽出的规则/坑/模式**：写成**多个永久卡**（上面的 1~4）。
- **工程约束**（在你项目里放到哪个类/如何封装）：放 **Project/SOP**，并**回链**到这些永久卡。
# 关联
- 近邻：[[永久卡=1卡1论断；需包含定义、机制、操作要点、反例、连接]]
