---
source: "<URL 或 论文/文档名>"
author: ""
year: ""
type: "paper|blog|doc|code"
---
## 捕获式Lambda和闭包：
为什么要特殊处理捕获式Lambda，这个地方主要就是是否捕获外部变量，编译器生成的一个匿名类的实例。这个对象包含：
注意，两个都是生成的闭包对象， 但是一个有状态，一个没有状态， 所谓的状态就是外部的引用或者拷贝。

1. **捕获的变量（作为成员变量存储状态）**
2. **重载的`operator()`（使对象可以像函数一样调用）**

```cpp
int bias = 5;
auto g = [bias](intx){ return x + bias; };
```
实际上，编译器生成了一个匿名类：
```cpp
class __anonymous_lambda {
private:
    int bias;  // 捕获的变量作为成员
public:
    __anonymous_lambda(int b) : bias(b) {}
    int operator()(int x) const { return x + bias; }
};

// g 实际上是这个匿名类的对象
auto g = __anonymous_lambda(bias);
```



### 我的解释
为什么要区分，因为捕获式Lambada，和非捕获式，完全不一样了，
捕获式lambda，生成一个匿名类，需要额外的存储区域，
但是非捕获式lambda，只需要记录函数本身，也就是可以记录一个指针地址即可，
所以捕获式Lambda，无法**转换为函数指针**
```cpp
int bias = 5;
auto g = [bias](intx){ return x + bias; };

// 不能转换为函数指针
using FnPtr = int(*)(int);
FnPtr p = g;  // ❌ 编译错误！
```

## 摘录要点
> 引文/代码片段/图（注明定位）

### 我的解释（不要省）
- 这段说了什么（自我语言，避免“纯复制”）
- 我以前哪里误解了？
- 对哪些永久卡有贡献？→ ## 摘录要点
> 引文/代码片段/图（注明定位）

### 我的解释（不要省）
- 这段说了什么（自我语言，避免“纯复制”）
- 我以前哪里误解了？
- 对哪些永久卡有贡献？→ ## 摘录要点
> 引文/代码片段/图（注明定位）

### 我的解释（不要省）
- 这段说了什么（自我语言，避免“纯复制”）
- 我以前哪里误解了？
- 对哪些永久卡有贡献？→ 
## 摘录要点
> 引文/代码片段/图（注明定位）

### 我的解释（不要省）
- 这段说了什么（自我语言，避免“纯复制”）
- 我以前哪里误解了？
- 对哪些永久卡有贡献？→ ## 摘录要点
> 引文/代码片段/图（注明定位）

### 我的解释（不要省）
- 这段说了什么（自我语言，避免“纯复制”）
- 我以前哪里误解了？
- 对哪些永久卡有贡献？→ ## 摘录要点
> 引文/代码片段/图（注明定位）

### 我的解释（不要省）
- 这段说了什么（自我语言，避免“纯复制”）
- 我以前哪里误解了？
- 对哪些永久卡有贡献？→ ## 摘录要点
> 引文/代码片段/图（注明定位）

### 我的解释（不要省）
- 这段说了什么（自我语言，避免“纯复制”）
- 我以前哪里误解了？
- 对哪些永久卡有贡献？→ 
# 关联
- 近邻：



# AI文本拷贝
