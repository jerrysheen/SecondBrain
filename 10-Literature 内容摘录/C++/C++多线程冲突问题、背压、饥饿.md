---
source: "<URL 或 论文/文档名>"
author: ""
year: ""
type: "paper|blog|doc|code"
---
## 摘录要点
多线程的执行速度， 并不能在主线程中控制，我们只能通过控制协议点，靠的是**同步协议**（mutex/atomic/condvar/semaphore/barrier），同步的方式来进行限速。
比如主线程执行100次， 起的独立线程可能执行1000次，要通过同步才能控制这种问题。

## 两个线程同时lock一个mutex
比如渲染线程执行1000次， 主线程执行100次，总有一些节点，如果两个同时修改某个数据，会修改到同一把mutex锁， 那么就会导致等待问题。
如果没用锁，就是**数据竞争**， 这是未定义行为。
如果加了锁，就是锁竞争，先加锁成功的赢，另一个阻塞。

### 饥饿、背压
饥饿： 极端情况下某个线程长期拿不到锁。
背压，bounded queue， queue塞满了，生产者阻塞了， 可能需要丢弃策略。

### 我的解释（不要省）
- 这段说了什么（自我语言，避免“纯复制”）
- 我以前哪里误解了？
- 对哪些永久卡有贡献？→ ## 摘录要点
> 引文/代码片段/图（注明定位）

### 我的解释（不要省）
- 这段说了什么（自我语言，避免“纯复制”）
- 我以前哪里误解了？
- 对哪些永久卡有贡献？→ ## 摘录要点
> 引文/代码片段/图（注明定位）

### 我的解释（不要省）
- 这段说了什么（自我语言，避免“纯复制”）
- 我以前哪里误解了？
- 对哪些永久卡有贡献？→ 
# 关联
- 近邻：
